import {
  derived,
  writable
} from "./chunk-5LCQEIM3.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  __publicField,
  action_destroyer,
  add_location,
  assign,
  attr_dev,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  component_subscribe,
  construct_svelte_component_dev,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  get_store_value,
  group_outros,
  init,
  insert_hydration_dev,
  mount_component,
  noop,
  onDestroy,
  outro_and_destroy_block,
  safe_not_equal,
  setContext,
  set_style,
  space,
  subscribe,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_argument,
  validate_each_keys,
  validate_slots,
  validate_store
} from "./chunk-F54QUVW6.js";

// node_modules/@roxi/routify/lib/runtime/Route/utils.js
var uriDecodeStringOrArray = (strOrArr) => strOrArr instanceof Array ? strOrArr.map(decodeURI) : decodeURI(strOrArr);
var URIDecodeObject = (obj) => Object.entries(obj).reduce(
  (_return, [key, value]) => ({
    ..._return,
    [key]: uriDecodeStringOrArray(value)
  }),
  {}
);

// node_modules/@roxi/routify/lib/runtime/Route/RouteFragment.js
var RouteFragment = class {
  constructor(route, node2, urlFragment, params2) {
    __publicField(this, "_params", {});
    this.route = route;
    this.node = node2;
    this.load = void 0;
    this.urlFragment = urlFragment;
    this.params = params2;
    this.parentElem = new Promise((resolve) => this.setElem = (el) => resolve(el));
    Object.defineProperty(this, "route", { enumerable: false });
  }
  get index() {
    return this.route.fragments.indexOf(this);
  }
  get params() {
    return URIDecodeObject(this._params);
  }
  set params(params2) {
    this._params = params2;
  }
};

// node_modules/@roxi/routify/lib/runtime/Route/Route.js
var URL_STATES = ["pushState", "replaceState", "popState"];
var Route = class {
  constructor(router, url2, mode, state = {}) {
    __publicField(this, "allFragments", []);
    __publicField(this, "loaded");
    __publicField(this, "load", {
      status: 200,
      error: null,
      maxage: null,
      props: {},
      redirect: null
    });
    const [, anchor] = url2.match(/#(.+)/) || [];
    this.router = router;
    this.url = url2;
    this.mode = mode;
    this.state = state;
    this.anchor = anchor;
    if (!router.rootNode) {
      this.router.log.error("Can't navigate without a rootNode");
      const err = new Error("Can't navigate without a rootNode");
      Object.assign(err, { routify: { router } });
      throw err;
    }
    if (!URL_STATES.includes(mode))
      throw new Error("url.mode must be pushState, replaceState or popState");
    this.allFragments = this._createFragments();
    this.log = router.log.createChild("[route]");
    this.log.debug("created", this);
  }
  get fragments() {
    return this.router.transformFragments.run(this.allFragments);
  }
  get params() {
    const match = this.url.match(/\?.+/);
    const query = match && match[0] || "";
    return Object.assign(
      {},
      ...this.allFragments.map((fragment) => fragment.params),
      this.router.queryHandler.parse(query, this)
    );
  }
  get leaf() {
    return [...this.allFragments].pop();
  }
  async loadRoute() {
    const { router } = this;
    const pipeline = [
      this.runBeforeUrlChangeHooks,
      this.loadComponents,
      this.runGuards,
      this.runPreloads
    ];
    this.loaded = new Promise(async (resolve, reject) => {
      for (const pretask of pipeline) {
        const passedPreTask = await pretask.bind(this)();
        const routerHasNewerPendingRoute = this !== router.pendingRoute.get();
        if (!router.pendingRoute.get()) {
          resolve({ route: router.activeRoute.get() });
          return;
        } else if (routerHasNewerPendingRoute) {
          router.pendingRoute.get().loaded.then(resolve).catch(reject);
          return;
        } else if (!passedPreTask) {
          router.pendingRoute.set(null);
          return;
        }
      }
      this.router.log.debug("set active route", this);
      const $activeRoute = this.router.activeRoute.get();
      if ($activeRoute)
        router.history.push($activeRoute);
      router.activeRoute.set(this);
      router.afterUrlChange.run({
        route: this,
        history: [...router.history].reverse()
      });
      this.router.log.debug("unset pending route", this);
      router.pendingRoute.set(null);
      resolve({ route: this });
    });
    return this.loaded;
  }
  async loadComponents() {
    this.log.debug("load components", this);
    await Promise.all(this.fragments.map((fragment) => fragment.node.loadModule()));
    return true;
  }
  async runPreloads() {
    var _a, _b;
    this.log.debug("run preloads", this);
    const ctx = {
      route: this,
      node: (_a = [...this.fragments].pop()) == null ? void 0 : _a.node
    };
    for (const fragment of this.fragments) {
      if ((_b = fragment.node.module) == null ? void 0 : _b.load) {
        fragment.load = await fragment.node.module.load(ctx);
        Object.assign(this.load, fragment.load);
        if (this.load.redirect)
          return this.router.url.replace(this.load.redirect);
      }
    }
    return this;
  }
  async runGuards() {
    this.log.debug(`running guards for ${this.url}`, this);
    const components = this.fragments.map((fragment) => fragment.node.module).filter((module) => module == null ? void 0 : module.guard);
    for (const module of components) {
      console.warn(
        '"guard" will be deprecated. Please use "load.redirect" instead.'
      );
      const result = await module.guard(this);
      if (!result)
        return false;
    }
    return true;
  }
  async runBeforeUrlChangeHooks() {
    return await this.router.beforeUrlChange.run({ route: this });
  }
  createFragment(node2, urlFragment = "", params2 = {}) {
    return new RouteFragment(this, node2, urlFragment, params2);
  }
  _createFragments() {
    const url2 = this.url.replace(/[#?].+/, "");
    const rootNode = this.router.rootNode;
    const nodeChain = this.router.rootNode.getChainTo(url2, {
      rootNode,
      allowDynamic: true,
      includeIndex: true
    });
    const fragments = nodeChain.map(
      (nc) => this.createFragment(nc.node, nc.fragment, nc.params)
    );
    return fragments;
  }
};

// node_modules/consolite/esm/index.mjs
var defaults = {
  filter: "",
  level: 3,
  levels: {
    default: 3,
    error: 1,
    warn: 2,
    debug: 4,
    trace: 4
  }
};
var noop2 = (x) => x;
var unique = (v, i, a) => a.indexOf(v) === i;
var escapeRegExp = (str) => str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
var escapeIfString = (str) => typeof str === "string" ? escapeRegExp(str) : str;
var Consolite = class {
  constructor(...prefix) {
    __publicField(this, "prefix", []);
    __publicField(this, "_filter", null);
    __publicField(this, "_level", null);
    __publicField(this, "_levels", {});
    __publicField(this, "parent", null);
    __publicField(this, "levels", new Proxy(this._levels, {
      ownKeys: (target) => {
        var _a;
        return [
          ...Object.keys(defaults.levels),
          ...Object.keys(((_a = this.parent) == null ? void 0 : _a.levels) || {}),
          ...Reflect.ownKeys(target)
        ].filter(unique);
      },
      getOwnPropertyDescriptor: (target, key) => ({
        value: target[key],
        enumerable: true,
        configurable: true
      }),
      get: (target, prop) => {
        var _a, _b;
        return target[prop] || target.default || ((_a = this.parent) == null ? void 0 : _a.levels[prop]) || ((_b = this.parent) == null ? void 0 : _b.levels.default) || defaults.levels[prop] || defaults.levels.default;
      },
      set: (target, prop, value) => target[prop] = value
    }));
    __publicField(this, "create", createLogger);
    this.prefix.push(...prefix);
    const withinLevel = (prop) => this.levels[prop] <= this.level;
    const passesFilter = () => typeof this.filter === "function" ? this.filter(prefix) : prefix.join("").match(escapeIfString(this.filter));
    this.register = (prop, fn) => Object.defineProperty(this, prop, {
      get: () => {
        const canBind = typeof fn === "function";
        const shouldPrint = withinLevel(prop) && passesFilter() && canBind;
        const prefixes = prefix.map((p) => typeof p === "string" ? p : p(prop, this));
        return shouldPrint ? fn.bind(console, ...prefixes) : noop2;
      }
    });
    Object.keys(console).forEach((prop) => this.register(prop, console[prop]));
  }
  get level() {
    var _a, _b, _c;
    return (_c = (_b = this._level) != null ? _b : (_a = this.parent) == null ? void 0 : _a.level) != null ? _c : defaults.level;
  }
  set level(val) {
    this._level = val;
  }
  get filter() {
    var _a, _b, _c;
    return (_c = (_b = this._filter) != null ? _b : (_a = this.parent) == null ? void 0 : _a.filter) != null ? _c : defaults.filter;
  }
  set filter(val) {
    this._filter = val;
  }
  get root() {
    var _a;
    return ((_a = this.parent) == null ? void 0 : _a.root) || this;
  }
  createChild(...prefix) {
    const child = createLogger(...this.prefix, ...prefix);
    child.parent = this;
    return child;
  }
  createParent(...prefix) {
    return createLogger(...prefix, ...this.prefix);
  }
};
var createLogger = (...prefix) => Object.assign(new Consolite(...prefix));

// node_modules/@roxi/routify/lib/runtime/utils/logger.js
var log = createLogger("[rf3]");
var createRootLogger = () => {
  Object.assign(log, loadState());
  return new Proxy(log, {
    get: (target, prop) => target[prop],
    set: (target, prop, value) => {
      target[prop] = value;
      saveState(log);
      return false;
    }
  });
};
var loadState = () => {
  if (typeof window === "undefined") {
    const level = process.env.DEBUG_LEVEL;
    const filter = process.env.DEBUG_FILTER;
    return { level, filter };
  } else {
    return JSON.parse(localStorage.getItem("__routify.logState") || "{}");
  }
};
var saveState = (log2) => {
  const { level, filter } = log2;
  if (typeof window === "undefined") {
    process.env.DEBUG_LEVEL = level;
    process.env.DEBUG_FILTER = filter;
  } else
    localStorage.setItem("__routify.logState", JSON.stringify({ filter, level }));
};
var debugWrapper = (fn, msg) => (...params2) => {
  const result = fn(...params2);
  log.debug(msg, { params: params2, result });
  return result;
};

// node_modules/@roxi/routify/lib/runtime/Global/BrowserAdapter.js
var createBrowserAdapter = (opts) => {
  const delimiter = (opts == null ? void 0 : opts.delimiter) || ";";
  return {
    toRouter: (url2, router) => {
      const formatRE = router.name ? `${router.name}=(.+?)` : `(.+?)`;
      const RE = new RegExp(`(^|${delimiter})${formatRE}(${delimiter}|$)`);
      const matches = url2.match(RE);
      return matches ? matches[2] : "/";
    },
    toBrowser: (routers) => routers.map((r) => (r.name ? `${r.name}=` : "") + r.url.external()).join(delimiter)
  };
};

// node_modules/@roxi/routify/lib/runtime/Global/Global.js
var AppInstance = class {
  constructor() {
    __publicField(this, "instances", []);
    __publicField(this, "browserAdapter", createBrowserAdapter());
    __publicField(this, "urlFromBrowser", (router) => {
      if (debugWrapper)
        return debugWrapper(
          this.browserAdapter.toRouter,
          "calling browserAdapter.toRouter"
        )(urlFromAddress(), router);
      return this.browserAdapter.toRouter(urlFromAddress(), router);
    });
    globalThis["__routify"] = this;
    this.log = createRootLogger();
  }
  get routers() {
    return [].concat(...this.instances.map((instance7) => instance7.routers));
  }
  register(instance7) {
    this.instances.push(instance7);
    return this;
  }
};
var appInstance = new AppInstance();

// node_modules/@roxi/routify/lib/runtime/utils/index.js
var getUrlFromClick = (event) => {
  const el = event.target.closest("a");
  const href = el && el.href;
  if (event.ctrlKey || event.metaKey || event.altKey || event.shiftKey || event.button || event.key && event.key !== "Enter" || event.defaultPrevented)
    return;
  if (!href || el.target || el.host !== location.host)
    return;
  const url2 = new URL(href);
  const relativeUrl = url2.pathname + url2.search + url2.hash;
  event.preventDefault();
  return relativeUrl;
};
var pathAndParamsToUrl = (path, params2 = {}, queryHandler, useWildcards) => {
  Object.entries(params2).forEach(([key, val]) => {
    if (path.includes(`[${key}]`)) {
      path = path.replace(`[${key}]`, val);
      delete params2[key];
    }
  });
  if (useWildcards)
    path = insertWildcards(path);
  return path + queryHandler(params2);
};
var insertWildcards = (str) => {
  return str.replace(/\[.*?\]/, ".*?");
};
var fromEntries = (iterable) => {
  return [...iterable].reduce((obj, [key, val]) => {
    obj[key] = val;
    return obj;
  }, {});
};
var populateUrl = (path, params2, route) => {
  const overloads = {};
  Object.entries(params2).forEach(([param, value]) => {
    const RE = new RegExp(`\\[(...)?${param}\\]|\\:${param}`);
    value = Array.isArray(value) ? value.join("/") : value;
    if (path.match(RE))
      path = path.replace(RE, encodeURI(value));
    else
      overloads[param] = value;
  });
  const query = route.router.queryHandler.stringify(overloads, route);
  return path + query;
};
var urlFromAddress = () => (({ pathname, search, hash }) => pathname + search + hash)(window.location);
var getGlobalContext = () => {
  console.log("Using helpers outside router context is not supported. Use at own risk.");
  const router = appInstance.routers[0];
  const route = router.activeRoute.get() || router.pendingRoute.get();
  return {
    childFragments: writable(route.allFragments),
    node: router.rootNode,
    fragment: route.allFragments[0],
    isActive: writable(false),
    router,
    route,
    parentContext: null,
    onDestroy: null,
    decorators: [],
    single: writable(true)
  };
};
var contexts = {
  get router() {
    return (getContext("routify-fragment-context") || getGlobalContext()).router;
  },
  get fragment() {
    return getContext("routify-fragment-context") || getGlobalContext();
  }
};
var getContextMaybe = (name) => {
  try {
    return getContext(name);
  } catch (err) {
  }
};
var getable = (value, start) => {
  const store = writable(value, start);
  return Object.assign(store, { get: () => get_store_value(store) });
};
var identicalRoutes = (...routes) => routes.map((route) => JSON.stringify([route == null ? void 0 : route.allFragments, route == null ? void 0 : route.url])).reduce((prev, curr) => prev === curr && curr);

// node_modules/@roxi/routify/lib/runtime/Router/urlReflectors/ReflectorBase.js
var BaseReflector = class {
  constructor(router) {
    this.router = router;
    this.log = this.router.log;
  }
  install() {
  }
  uninstall() {
  }
  reflect() {
  }
};

// node_modules/@roxi/routify/lib/common/RNode.js
var RNode = class {
  constructor(name, module, instance7) {
    __publicField(this, "parent");
    __publicField(this, "meta", {});
    __publicField(this, "id");
    __publicField(this, "_regex", {});
    __publicField(this, "_paramKeys", {});
    this.instance = instance7;
    this.name = name;
    instance7.nodeIndex.push(this);
    this.module = module;
    Object.defineProperty(this, "instance", { enumerable: false });
    Object.defineProperty(this, "parent", { enumerable: false });
  }
  appendChild(child) {
    if (child.instance)
      child.parent = this;
  }
  createChild(name, module) {
    const node2 = this.instance.createNode(name, module);
    this.appendChild(node2);
    return node2;
  }
  get descendants() {
    return this.instance.nodeIndex.filter(
      (node2) => node2.ancestors.find((n) => n === this)
    );
  }
  remove() {
    const { nodeIndex } = this.instance;
    const index = nodeIndex.findIndex((node2) => node2 === this);
    nodeIndex.splice(index, 1);
  }
  get ancestors() {
    let node2 = this;
    const ancestors = [];
    while (node2 = node2.parent)
      ancestors.push(node2);
    return ancestors;
  }
  get root() {
    let node2 = this;
    while (node2.parent)
      node2 = node2.parent;
    return node2;
  }
  get isRoot() {
    return this === this.root;
  }
  get children() {
    return this.instance.nodeIndex.filter((node2) => node2.parent === this);
  }
  get level() {
    var _a;
    return (((_a = this.parent) == null ? void 0 : _a.level) || 0) + 1;
  }
  get regex() {
    const { name } = this;
    if (!this._regex[name])
      this._regex[name] = this.instance.utils.getRegexFromName(this.name);
    return this._regex[name];
  }
  set regex(value) {
    this._regex[this.name] = new RegExp(value);
  }
  get paramKeys() {
    const { name } = this;
    if (!this._paramKeys[name])
      this._paramKeys[name] = this.instance.utils.getFieldsFromName(this.name);
    return this._paramKeys[name];
  }
  getParams(urlFragment) {
    const values = this.instance.utils.getValuesFromPath(this.regex, urlFragment);
    return this.instance.utils.mapFieldsWithValues(this.paramKeys, values);
  }
  traverse(path, allowDynamic = false, includeIndex = false, silent = false) {
    var _a;
    const isNamed = !path.startsWith("/") && !path.startsWith(".");
    return isNamed ? this.root.instance.nodeIndex.find((node2) => node2.meta.name === path) : (_a = this.getChainTo(path, { allowDynamic, includeIndex, silent })) == null ? void 0 : _a.pop().node;
  }
  getChainTo(path, options) {
    options = {
      ...{ allowDynamic: true, includeIndex: true },
      ...options
    };
    const originNode = path.startsWith("/") ? options.rootNode || this.root : this;
    const stepsToLeaf = path.split("/").filter((snip) => snip !== ".").filter(Boolean);
    let currentNodeStep = {
      node: originNode,
      stepsToLeaf,
      params: {},
      fragment: ""
    };
    const nodeSteps = [currentNodeStep];
    let inStaticDeadEnd = false;
    let inDynamicDeadEnd = false;
    while (currentNodeStep.stepsToLeaf.length) {
      const [nextStep, ...restSteps] = currentNodeStep.stepsToLeaf;
      const nextNode = nextStep === ".." ? currentNodeStep.node.parent : !inStaticDeadEnd && currentNodeStep.node.children.find(
        (node2) => node2.name === nextStep
      ) || options.allowDynamic && !inDynamicDeadEnd && currentNodeStep.node.children.filter(({ meta: meta2 }) => meta2.dynamic && !meta2.dynamicSpread).find((node2) => node2.regex.test(nextStep)) || options.allowDynamic && currentNodeStep.node.children.find(
        (node2) => node2.meta.dynamicSpread
      );
      if (nextNode) {
        const nodeStep = {
          node: nextNode,
          params: nextNode.meta.dynamicSpread ? [nextStep] : nextNode.meta.dynamic ? nextNode.getParams(nextStep) : {},
          stepsToLeaf: restSteps,
          fragment: nextStep
        };
        currentNodeStep = nodeStep;
        nodeSteps.push(nodeStep);
      } else if (!options.allowDynamic && options.silent)
        return null;
      else if (!options.allowDynamic && !options.silent)
        throw new Error(
          `${nodeSteps.map((ns) => ns.node.name || "root").join("/")} could not travel to ${nextStep}`
        );
      else if (currentNodeStep.node.meta.dynamicSpread) {
        currentNodeStep.params.push(nextStep);
        currentNodeStep.fragment += `/${nextStep}`;
        currentNodeStep.stepsToLeaf.shift();
        inDynamicDeadEnd = false;
        inStaticDeadEnd = false;
      } else {
        nodeSteps.pop();
        currentNodeStep = [...nodeSteps].pop();
        inDynamicDeadEnd = inStaticDeadEnd;
        inStaticDeadEnd = true;
        if (!currentNodeStep && options.silent)
          return null;
        else if (!currentNodeStep && !options.silent)
          throw new Error(`Could not find path "${path}" from ${this.name}`);
      }
    }
    try {
      const indexNode = options.includeIndex && currentNodeStep.node.traverse("./index");
      if (indexNode)
        nodeSteps.push({
          node: indexNode,
          stepsToLeaf: [],
          params: {},
          fragment: ""
        });
    } catch (err) {
    }
    nodeSteps.forEach((ns) => {
      ns.params = Array.isArray(ns.params) ? { [ns.node.name.replace(/\[\.\.\.(.+)\]/, "$1")]: ns.params } : ns.params;
    });
    return nodeSteps;
  }
  toJSON() {
    return {
      ...this,
      children: [...this.children]
    };
  }
  get path() {
    return "/" + [this, ...this.ancestors].reverse().map((node2) => node2.name).filter(Boolean).join("/");
  }
};

// node_modules/@roxi/routify/lib/runtime/Instance/Node.svelte
function create_else_block(ctx) {
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(21:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[1] && create_if_block_1(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(15:0) {#if Component}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let component;
  let current;
  const component_spread_levels = [ctx[0], { context: ctx[2] }];
  let component_props = {
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  for (let i = 0; i < component_spread_levels.length; i += 1) {
    component_props = assign(component_props, component_spread_levels[i]);
  }
  component = new ctx[1]({ props: component_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(component.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(component.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(component, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const component_changes = dirty & 5 ? get_spread_update(component_spread_levels, [
        dirty & 1 && get_spread_object(ctx2[0]),
        dirty & 4 && { context: ctx2[2] }
      ]) : {};
      if (dirty & 32) {
        component_changes.$$scope = { dirty, ctx: ctx2 };
      }
      component.$set(component_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(component.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(component.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(component, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(16:4) {#if Component}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(17:8) <Component {...passthrough} {context}>",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var CTX = "routify-fragment-context";
function instance($$self, $$props, $$invalidate) {
  var _a;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Node", slots, ["default"]);
  let { node: node2 } = $$props;
  let { passthrough } = $$props;
  const context2 = { ...getContext(CTX), node: node2 };
  setContext(CTX, context2);
  let Component = (_a = node2.module) == null ? void 0 : _a.default;
  if (!Component && node2.asyncModule)
    node2.asyncModule().then((r) => $$invalidate(1, Component = r.default));
  $$self.$$.on_mount.push(function() {
    if (node2 === void 0 && !("node" in $$props || $$self.$$.bound[$$self.$$.props["node"]])) {
      console.warn("<Node> was created without expected prop 'node'");
    }
    if (passthrough === void 0 && !("passthrough" in $$props || $$self.$$.bound[$$self.$$.props["passthrough"]])) {
      console.warn("<Node> was created without expected prop 'passthrough'");
    }
  });
  const writable_props = ["node", "passthrough"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Node> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$invalidate(3, node2 = $$props2.node);
    if ("passthrough" in $$props2)
      $$invalidate(0, passthrough = $$props2.passthrough);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    setContext,
    node: node2,
    passthrough,
    CTX,
    context: context2,
    Component
  });
  $$self.$inject_state = ($$props2) => {
    if ("node" in $$props2)
      $$invalidate(3, node2 = $$props2.node);
    if ("passthrough" in $$props2)
      $$invalidate(0, passthrough = $$props2.passthrough);
    if ("Component" in $$props2)
      $$invalidate(1, Component = $$props2.Component);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [passthrough, Component, context2, node2, slots, $$scope];
}
var Node = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { node: 3, passthrough: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Node",
      options,
      id: create_fragment.name
    });
  }
  get node() {
    throw new Error("<Node>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set node(value) {
    throw new Error("<Node>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get passthrough() {
    throw new Error("<Node>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set passthrough(value) {
    throw new Error("<Node>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Node_default = Node;

// node_modules/@roxi/routify/lib/runtime/Instance/RNodeRuntime.js
var RNodeRuntime = class extends RNode {
  constructor(name, module, instance7, asyncModule) {
    super(name, module, instance7);
    __publicField(this, "asyncModule");
    __publicField(this, "importTree", (snapshotRoot) => {
      const queue = [[this, snapshotRoot]];
      while (queue.length) {
        const [node2, snapshot] = queue.pop();
        const { children: children2, ...nodeSnapshot } = snapshot;
        Object.assign(node2, nodeSnapshot);
        for (const childSnapshot of children2) {
          const childNode = node2.createChild(
            snapshot.name || snapshot.rootName || ""
          );
          queue.push([childNode, childSnapshot]);
        }
      }
      return this;
    });
    this.module = module;
    this.asyncModule = asyncModule;
  }
  get children() {
    return this.instance.nodeIndex.filter((node2) => node2.parent === this).sort((prev, curr) => (prev.meta.order || 0) - (curr.meta.order || 0));
  }
  get pages() {
    return this.pagesWithIndex.filter((node2) => node2.name !== "index");
  }
  get pagesWithIndex() {
    return this.children.filter((node2) => !node2.meta.fallback).filter((node2) => !node2.name.startsWith("_")).filter((node2) => !node2.name.includes("[")).filter((node2) => {
      var _a;
      return !(((_a = node2.meta) == null ? void 0 : _a.order) === false);
    });
  }
  async getRawComponent() {
    const module = await this.loadModule();
    return module == null ? void 0 : module.default;
  }
  async loadModule() {
    if (!this.module && this.asyncModule) {
      this.module = await this.asyncModule();
    }
    return this.module;
  }
  get component() {
    const node2 = this;
    return function(options) {
      options.props = {
        ...options.props,
        passthrough: options.props,
        node: node2
      };
      return new Node_default({ ...options });
    };
  }
  get _fallback() {
    var _a;
    return this.children.find((node2) => node2.meta.fallback) || ((_a = this.parent) == null ? void 0 : _a._fallback);
  }
};

// node_modules/@roxi/routify/lib/runtime/Instance/UrlParamUtils.js
var defaultRe = /\[(.+?)\]/gm;
var UrlParamUtils = class {
  constructor(RE = defaultRe) {
    __publicField(this, "getFieldsFromName", (name) => [...name.matchAll(this.RE)].map((v) => v[1]));
    __publicField(this, "getRegexFromName", (name) => new RegExp("^" + name.replace(this.RE, "(.+)") + "$"));
    __publicField(this, "getValuesFromPath", (re, path) => (path.match(re) || []).slice(1));
    __publicField(this, "mapFieldsWithValues", (fields, values) => this.haveEqualLength(fields, values) && fields.reduce((map, field, index) => {
      map[field] = values[index];
      return map;
    }, {}));
    __publicField(this, "haveEqualLength", (fields, values) => {
      if (fields.length !== values.length)
        throw new Error(
          `fields and values should be of same length
fields: ${JSON.stringify(fields)}
values: ${JSON.stringify(values)}`
        );
      return true;
    });
    this.RE = RE;
  }
};

// node_modules/@roxi/routify/lib/common/Routify.js
var Routify = class {
  constructor() {
    __publicField(this, "NodeConstructor");
    __publicField(this, "NodeType");
    __publicField(this, "nodeIndex", []);
    __publicField(this, "rootNodes", {});
    __publicField(this, "utils", new UrlParamUtils());
  }
  createNode(name, module) {
    return new this.NodeConstructor(name, module, this);
  }
};

// node_modules/@roxi/routify/lib/runtime/Instance/RoutifyRuntime.js
var RoutifyRuntime = class extends Routify {
  constructor(options) {
    super();
    __publicField(this, "NodeConstructor", RNodeRuntime);
    __publicField(this, "mode", "runtime");
    __publicField(this, "routers", []);
    __publicField(this, "rootNodes", {});
    this.options = options;
    if (options.routes) {
      this.rootNodes[options.routes.rootName || "unnamed"] = this.createNode(
        options.routes.rootName
      ).importTree(options.routes);
    }
    this.global = appInstance.register(this);
    Object.defineProperty(this, "routers", { enumerable: false });
    this.log = this.global.log;
  }
};

// node_modules/hookar/esm/util.mjs
var runOnce = (cb) => {
  let hasRun;
  const wrapper = (...params2) => {
    if (hasRun)
      return;
    hasRun = true;
    return cb(...params2);
  };
  return wrapper;
};

// node_modules/hookar/esm/index.mjs
var createHooksCollection = (runner) => {
  const hooks = [];
  const hooksCollection = (hook) => {
    hooks.push(hook);
    return () => hooks.splice(hooks.indexOf(hook), 1);
  };
  hooksCollection.hooks = hooks;
  hooksCollection.run = runner(hooks);
  hooksCollection.runOnce = runOnce(runner(hooks));
  return hooksCollection;
};
var createPipelineCollection = (type) => createHooksCollection(
  (hooks) => (value, ...rest) => hooks.reduce(
    (pipedValue, hook) => (pipedValue == null ? void 0 : pipedValue.then) ? pipedValue.then((r) => hook(r, ...rest)) : hook(pipedValue, ...rest),
    value
  )
);
var createSequenceHooksCollection = (type) => createHooksCollection(
  (hooks) => (value, ...rest) => hooks.reduce(
    (last, hook) => (last == null ? void 0 : last.then) ? last.then((_) => hook(value, ...rest)) : hook(value, ...rest),
    value
  )
);
var createGuardsCollection = (type) => createHooksCollection(
  (hooks) => (value, ...rest) => hooks.reduce(
    (pipedValue, hook) => (pipedValue == null ? void 0 : pipedValue.then) ? pipedValue.then((r) => r && hook(value, ...rest)) : pipedValue && hook(value, ...rest),
    value || true
  )
);

// node_modules/@roxi/routify/lib/runtime/Router/urlReflectors/Address.js
var AddressReflector = class extends BaseReflector {
  constructor(router) {
    super(router);
    __publicField(this, "reflect", () => {
      const { mode } = get_store_value(this.router.activeRoute);
      if (mode === "popState")
        return false;
      const { routers, browserAdapter } = this.router.instance.global;
      const addressRouters = routers.filter(
        (router) => router.urlReflector instanceof this.constructor
      );
      const url2 = browserAdapter.toBrowser(addressRouters);
      this.log.debug("pushing internal url to browser history", {
        mode,
        url: url2,
        currentBrowserUrl: urlFromAddress(),
        currentInternalUrl: this.router.url.internal()
      });
      history[`${mode}Native`]({}, "", url2);
    });
    const { instance: instance7, urlRewrites } = router;
    const { urlFromBrowser, browserAdapter } = instance7.global;
    if (!history["onPushstate"]) {
      this.log.debug("polyfill history hooks");
      polyfillHistory();
    }
    const createStateEventHandler = (method) => {
      return function(data, title, url2) {
        var _a, _b;
        const routerName = (_b = (_a = data == null ? void 0 : data.routify) == null ? void 0 : _a.router) != null ? _b : false;
        if (routerName === false)
          url2 = browserAdapter.toRouter(url2, router);
        else if (routerName !== router.name)
          return false;
        for (const rewrite of urlRewrites)
          url2 = rewrite.toInternal(url2, { router });
        router.url[method](url2);
      };
    };
    this.absorb = () => router.url.replace(urlFromBrowser(router));
    this._pushstateHandler = createStateEventHandler("push");
    this._replacestateHandler = createStateEventHandler("replace");
    this._popstateHandler = () => router.url.pop(urlFromBrowser(router));
  }
  install() {
    this.hooks = [
      history["onPushstate"](this._pushstateHandler),
      history["onReplacestate"](this._replacestateHandler),
      history["onPopstate"](this._popstateHandler)
    ];
    if (!get_store_value(this.router.activeRoute))
      this.absorb();
    else
      this.reflect();
  }
  uninstall() {
    this.hooks.forEach((unreg) => unreg());
    setTimeout(() => this.reflect());
  }
};
function polyfillHistory() {
  const hooks = {
    onPushstate: createSequenceHooksCollection(),
    onReplacestate: createSequenceHooksCollection(),
    onPopstate: createSequenceHooksCollection()
  };
  Object.assign(history, hooks);
  const { pushState, replaceState } = history;
  history["pushStateNative"] = pushState;
  history["replaceStateNative"] = replaceState;
  history.pushState = hooks.onPushstate.run;
  history.replaceState = hooks.onReplacestate.run;
  window.addEventListener("popstate", hooks.onPopstate.run);
  return true;
}

// node_modules/@roxi/routify/lib/runtime/Router/urlReflectors/Internal.js
var InternalReflector = class extends BaseReflector {
};

// node_modules/@roxi/routify/lib/runtime/plugins/reset/index.js
var parseModuleName = (str) => {
  const matches = str.match(/^(.+?)(\+)?$/);
  const [, name, prepend] = matches;
  return { name, prepend };
};
var handlers = {
  boolean(route, bool, fragment) {
    const index = fragment.index;
    return handlers.number(route, index, fragment);
  },
  number(route, num, fragment) {
    const index = fragment.index;
    const start = index - num;
    route.allFragments.splice(start, num);
  },
  string(route, str, fragment) {
    const selfIndex = fragment.index;
    const precedingFragments = route.allFragments.slice(0, selfIndex + 1);
    let nextFragment;
    const { name, prepend } = parseModuleName(str);
    while (precedingFragments.length) {
      nextFragment = precedingFragments.pop();
      const matchingSiblingNode = nextFragment.node.children.find(
        (node2) => node2.meta.moduleName === name
      );
      if (matchingSiblingNode) {
        if (!prepend)
          route.allFragments.splice(0, fragment.index);
        route.allFragments.unshift(route.createFragment(matchingSiblingNode));
        precedingFragments.splice(0);
      }
    }
  }
};
var handleFragment = (route) => (fragment) => {
  const { reset } = fragment.node.meta;
  if (reset)
    handlers[typeof reset](route, reset, fragment);
};
var reset_default = () => {
  return {
    beforeUrlChange: ({ route }) => {
      const fragments = [...route.allFragments];
      fragments.forEach(handleFragment(route));
      return true;
    }
  };
};

// node_modules/@roxi/routify/lib/common/utils.js
var addPropsToComp = (Comp, props) => {
  const ssrWrapper = (Comp2, props2) => ({
    ...Comp2,
    $$render: (...params2) => {
      params2[1] = { ...params2[1], ...props2 };
      return Comp2.$$render(...params2);
    }
  });
  const domWrapper = (Comp2, props2) => function(options) {
    return new Comp2({ ...options, props: { ...options.props, ...props2 } });
  };
  const wrapper = Comp["$$render"] ? ssrWrapper : domWrapper;
  return wrapper(Comp, props);
};
var next = (store, wanted, strict) => new Promise((resolve) => {
  let unsub;
  unsub = store.subscribe((value) => {
    if (!unsub)
      return;
    if (typeof wanted === "undefined" || value === wanted || value == wanted && !strict || typeof wanted === "function" && wanted(value)) {
      resolve(value);
      unsub;
    }
  });
});
var createThrottle = () => {
  const map = /* @__PURE__ */ new Map();
  const throttle2 = async (fn) => {
    const fnStr = fn.toString();
    map.set(fnStr, map.get(fnStr) || { isRunning: false, runAgain: false });
    const s = map.get(fnStr);
    if (s.isRunning)
      s.runAgain = true;
    else {
      s.isRunning = true;
      await fn();
      s.isRunning = false;
      if (s.runAgain) {
        s.runAgain = false;
        await throttle2(fn);
      }
    }
  };
  return throttle2;
};
var throttle = createThrottle();

// node_modules/@roxi/routify/lib/runtime/Router/Router.js
var stripNullFields = (obj) => Object.fromEntries(Object.entries(obj).filter(([_, v]) => v != null));
var normalizeRouterOptions = (options, config) => {
  config = config || {
    name: "",
    beforeRouterInit: [],
    afterRouterInit: [],
    urlRewrite: [],
    beforeUrlChange: [],
    afterUrlChange: [],
    transformFragments: [],
    onDestroy: []
  };
  const { plugins, ...optionsOnly } = options;
  const optionsGroups = [...plugins || [], optionsOnly];
  optionsGroups.forEach((pluginOptions) => {
    if ("plugin" in pluginOptions)
      normalizeRouterOptions(pluginOptions, config);
    Object.entries(pluginOptions).forEach(([field, value]) => {
      if (Array.isArray(config[field]))
        config[field].push(...[value].flat().filter(Boolean));
      else
        config[field] = value || config[field];
    });
  });
  return config;
};
var defaultPlugins = [reset_default()];
var Router = class {
  constructor(input) {
    __publicField(this, "pendingRoute", getable(null));
    __publicField(this, "activeRoute", getable(null));
    __publicField(this, "_urlReflector", null);
    __publicField(this, "urlRewrites", []);
    __publicField(this, "beforeRouterInit", createSequenceHooksCollection());
    __publicField(this, "afterRouterInit", createSequenceHooksCollection());
    __publicField(this, "beforeUrlChange", createGuardsCollection());
    __publicField(this, "afterUrlChange", createSequenceHooksCollection());
    __publicField(this, "transformFragments", createPipelineCollection());
    __publicField(this, "onDestroy", createSequenceHooksCollection());
    __publicField(this, "parentElem", null);
    __publicField(this, "queryHandler", {
      parse: (search, route) => fromEntries(new URLSearchParams(search)),
      stringify: (params2, route) => {
        const query = new URLSearchParams(params2).toString();
        return query ? `?${query}` : "";
      }
    });
    __publicField(this, "url", {
      internal: () => this.url.getPending() || this.url.getActive(),
      external: () => this.getExternalUrl(),
      getActive: () => {
        var _a;
        return (_a = get_store_value(this.activeRoute)) == null ? void 0 : _a.url;
      },
      getPending: () => {
        var _a;
        return (_a = get_store_value(this.pendingRoute)) == null ? void 0 : _a.url;
      },
      toString: () => this.url.internal(),
      set: this._setUrl.bind(this),
      push: (url2, state = {}) => this._setUrl(url2, "pushState", false, state),
      replace: (url2, state = {}) => this._setUrl(url2, "replaceState", false, state),
      pop: (url2, state = {}) => this._setUrl(url2, "popState", false, state)
    });
    __publicField(this, "ready", async () => !this.pendingRoute.get() && this.activeRoute.get() || next(this.activeRoute, (x) => !!x));
    __publicField(this, "history", []);
    __publicField(this, "setParentElem", (elem) => {
      this.parentElem = elem.parentElement;
      elem["__routify_meta"] = elem["__routify_meta"] || {};
      elem["__routify_meta"].router = this;
    });
    __publicField(this, "getExternalUrl", (url2) => {
      const result = this.urlRewrites.reduce(
        (_url, rewrite) => rewrite.toExternal(_url, { router: this }),
        url2 || this.url.internal()
      );
      return result;
    });
    __publicField(this, "getInternalUrl", (url2) => this.urlRewrites.reduce(
      (_url, rewrite) => rewrite.toInternal(_url, { router: this }),
      url2
    ));
    const { subscribe: subscribe2, set } = writable(this);
    this.subscribe = subscribe2;
    this.triggerStore = () => set(this);
    const oldRouter = appInstance.routers.find((r) => r.name == (input.name || ""));
    if (oldRouter)
      return oldRouter;
    else {
      input.plugins = [...input.plugins || [], ...defaultPlugins].filter(Boolean);
      this.init(input);
      this.params = derived(this.activeRoute, ($activeRoute) => $activeRoute.params);
      this.afterUrlChange(() => setTimeout(() => this._urlReflector.reflect()));
      this.activeRoute.get = () => get_store_value(this.activeRoute);
      this.pendingRoute.get = () => get_store_value(this.pendingRoute);
    }
  }
  init(input) {
    const firstInit = !this.options;
    input = stripNullFields(input);
    this.options = normalizeRouterOptions({ ...this.options, ...input });
    let {
      instance: instance7,
      rootNode,
      name,
      routes,
      urlRewrite,
      urlReflector,
      url: url2,
      passthrough,
      beforeUrlChange: beforeUrlChange2,
      afterUrlChange: afterUrlChange2,
      transformFragments,
      onDestroy: onDestroy2,
      beforeRouterInit,
      afterRouterInit,
      queryHandler
    } = this.options;
    if (queryHandler)
      this.queryHandler = queryHandler;
    beforeUrlChange2.forEach(this.beforeUrlChange);
    transformFragments.forEach(this.transformFragments);
    afterUrlChange2.forEach(this.afterUrlChange);
    onDestroy2.forEach(this.onDestroy);
    beforeRouterInit.forEach(this.beforeRouterInit);
    afterRouterInit.forEach(this.afterRouterInit);
    this.beforeRouterInit.run({ router: this, firstInit });
    const parentCmpCtx = getContextMaybe("routify-fragment-context");
    this.instance = instance7 || this.instance || (parentCmpCtx == null ? void 0 : parentCmpCtx.route.router.instance) || appInstance.instances[0] || new RoutifyRuntime({});
    this.name = name;
    this.urlRewrites = urlRewrite;
    this.log = this.log || this.instance.log.createChild(this.name || "[unnamed instance]");
    if (passthrough && !(passthrough instanceof Router))
      passthrough = (parentCmpCtx == null ? void 0 : parentCmpCtx.route.router) || passthrough;
    this.passthrough = passthrough || this.passthrough;
    appInstance.instances.forEach((inst) => {
      const index = inst.routers.indexOf(this);
      if (index !== -1)
        inst.routers.splice(index, 1);
    });
    this.instance.routers.push(this);
    if (routes && !this.rootNode)
      this.importRoutes(routes);
    this.parentCmpCtx = parentCmpCtx;
    this.rootNode = rootNode || this.rootNode || this.instance.rootNodes.default;
    this.log.debug("initiated router");
    if (this.url.getActive()) {
      this.log.debug("router was created with activeUrl");
      this._setUrl(this.url.getActive(), "pushState", true);
    }
    const shouldInstallUrlReflector = !this.urlReflector || urlReflector && !(this.urlReflector instanceof urlReflector);
    if (shouldInstallUrlReflector) {
      urlReflector = urlReflector || (typeof window != "undefined" ? AddressReflector : InternalReflector);
      this.setUrlReflector(urlReflector);
    }
    if (url2)
      this.url.replace(url2);
    this.triggerStore();
    this.afterRouterInit.run({ router: this, firstInit });
  }
  importRoutes(routes) {
    this.rootNode = this.instance.createNode().importTree(routes);
    this.instance.rootNodes[routes.rootName || "unnamed"] = this.rootNode;
  }
  async _setUrl(url2, mode, isInternal, state) {
    if (!isInternal)
      url2 = this.getInternalUrl(url2);
    url2 = url2 || "/";
    url2 = url2.replace(/(.+)\/+([#?]|$)/, "$1$2");
    const { activeRoute: activeRoute2, pendingRoute: pendingRoute2 } = this;
    const { debug, groupCollapsed, trace, groupEnd } = this.log;
    if (this.log.level >= 4) {
      const info = {
        url: url2,
        mode,
        prev: this.url.internal(),
        browserOld: urlFromAddress(),
        state
      };
      [groupCollapsed("set url", info), trace(), groupEnd()];
    }
    if (!url2.startsWith("/"))
      url2 = url2.replace(new URL(url2).origin, "");
    const route = new Route(this, url2, mode, state);
    const currentRoute = pendingRoute2.get() || activeRoute2.get();
    if (identicalRoutes(currentRoute, route)) {
      debug("current route is identical - skip", currentRoute, route);
      return true;
    }
    route.log.debug("set pending route", route);
    pendingRoute2.set(route);
    await route.loadRoute();
    return true;
  }
  destroy() {
    this.log.debug(`destroying router`);
    this.instance.routers = this.instance.routers.filter((router) => router !== this);
    this.onDestroy.run({ router: this });
  }
  get urlReflector() {
    return this._urlReflector;
  }
  setUrlReflector(UrlReflector) {
    var _a;
    (_a = this._urlReflector) == null ? void 0 : _a.uninstall();
    this._urlReflector = new UrlReflector(this);
    this._urlReflector.install();
    this.triggerStore();
  }
};
var createRouter = (options) => new Router(options);

// node_modules/@roxi/routify/lib/runtime/renderer/DecoratorWrapper.svelte
function create_default_slot2(ctx) {
  let current;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[7], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(default_slot_template, ctx2[7], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(25:0) <svelte:component this={lastDecorator} {Parent} {context}>",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[2];
  function switch_props(ctx2) {
    return {
      props: {
        Parent: ctx2[1],
        context: ctx2[0],
        $$slots: { default: [create_default_slot2] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const switch_instance_changes = {};
      if (dirty & 2)
        switch_instance_changes.Parent = ctx2[1];
      if (dirty & 1)
        switch_instance_changes.context = ctx2[0];
      if (dirty & 128) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (switch_value !== (switch_value = ctx2[2])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let decoClones;
  let lastDecorator;
  let Parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DecoratorWrapper", slots, ["default"]);
  let { decorators = null, nested = false, context: context2 } = $$props;
  if (!nested)
    onDestroy(() => context2.onDestroy.run());
  $$self.$$.on_mount.push(function() {
    if (context2 === void 0 && !("context" in $$props || $$self.$$.bound[$$self.$$.props["context"]])) {
      console.warn("<DecoratorWrapper> was created without expected prop 'context'");
    }
  });
  const writable_props = ["decorators", "nested", "context"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<DecoratorWrapper> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("decorators" in $$props2)
      $$invalidate(3, decorators = $$props2.decorators);
    if ("nested" in $$props2)
      $$invalidate(4, nested = $$props2.nested);
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("$$scope" in $$props2)
      $$invalidate(7, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    addPropsToComp,
    DecoratorWrapper: DecoratorWrapper_default,
    decorators,
    nested,
    context: context2,
    decoClones,
    Parent,
    lastDecorator
  });
  $$self.$inject_state = ($$props2) => {
    if ("decorators" in $$props2)
      $$invalidate(3, decorators = $$props2.decorators);
    if ("nested" in $$props2)
      $$invalidate(4, nested = $$props2.nested);
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("decoClones" in $$props2)
      $$invalidate(5, decoClones = $$props2.decoClones);
    if ("Parent" in $$props2)
      $$invalidate(1, Parent = $$props2.Parent);
    if ("lastDecorator" in $$props2)
      $$invalidate(2, lastDecorator = $$props2.lastDecorator);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 9) {
      $:
        $$invalidate(5, decoClones = [...decorators || context2.decorators]);
    }
    if ($$self.$$.dirty & 32) {
      $:
        $$invalidate(2, lastDecorator = decoClones.pop());
    }
    if ($$self.$$.dirty & 33) {
      $:
        $$invalidate(1, Parent = addPropsToComp(DecoratorWrapper_default, {
          decorators: decoClones,
          context: context2,
          nested: true
        }));
    }
  };
  return [context2, Parent, lastDecorator, decorators, nested, decoClones, slots, $$scope];
}
var DecoratorWrapper_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { decorators: 3, nested: 4, context: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DecoratorWrapper_1",
      options,
      id: create_fragment2.name
    });
  }
  get decorators() {
    throw new Error("<DecoratorWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set decorators(value) {
    throw new Error("<DecoratorWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nested() {
    throw new Error("<DecoratorWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nested(value) {
    throw new Error("<DecoratorWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get context() {
    throw new Error("<DecoratorWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<DecoratorWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DecoratorWrapper_default = DecoratorWrapper_1;

// node_modules/@roxi/routify/lib/runtime/decorators/Noop.svelte
function create_fragment3(ctx) {
  let current;
  const default_slot_template = ctx[2].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[1],
            !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(default_slot_template, ctx2[1], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Noop", slots, ["default"]);
  let { context: context2 = null } = $$props;
  context2;
  const writable_props = ["context"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Noop> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ context: context2 });
  $$self.$inject_state = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [context2, $$scope, slots];
}
var Noop = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { context: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Noop",
      options,
      id: create_fragment3.name
    });
  }
  get context() {
    throw new Error("<Noop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<Noop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Noop_default = Noop;

// node_modules/@roxi/routify/lib/runtime/renderer/RenderFragment.svelte
var file = "node_modules\\@roxi\\routify\\lib\\runtime\\renderer\\RenderFragment.svelte";
function create_if_block2(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = DecoratorWrapper_default;
  function switch_props(ctx2) {
    return {
      props: {
        context: ctx2[0],
        $$slots: { default: [create_default_slot3] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & 1)
        switch_instance_changes.context = ctx2[0];
      if (dirty & 8388727) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (switch_value !== (switch_value = DecoratorWrapper_default)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(36:0) {#if isVisible && NodeComponent}",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let component;
  let current;
  component = new ComposeFragments_default({
    props: {
      options: {
        multi: ctx[20],
        decorator: ctx[21],
        props: ctx[1],
        options: ctx[22]
      },
      context: ctx[0]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(component.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(component.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(component, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const component_changes = {};
      if (dirty & 7340034)
        component_changes.options = {
          multi: ctx2[20],
          decorator: ctx2[21],
          props: ctx2[1],
          options: ctx2[22]
        };
      if (dirty & 1)
        component_changes.context = ctx2[0];
      component.$set(component_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(component.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(component.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(component, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(49:12) {#if $childFragments.length || (multi && !multi?.single)}",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  var _a;
  let if_block_anchor;
  let current;
  let if_block = (ctx[6].length || ctx[20] && !((_a = ctx[20]) == null ? void 0 : _a.single)) && create_if_block_12(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      var _a2;
      if (ctx2[6].length || ctx2[20] && !((_a2 = ctx2[20]) == null ? void 0 : _a2.single)) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1048640) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_12(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(41:8) <svelte:component             this={NodeComponent}             {...compProps}             context={userContext}             let:props             let:multi             let:decorator             let:options>",
    ctx
  });
  return block;
}
function create_default_slot3(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [ctx[5], { context: ctx[4] }];
  var switch_value = ctx[2];
  function switch_props(ctx2) {
    let switch_instance_props = {
      $$slots: {
        default: [
          create_default_slot_1,
          ({ props, multi, decorator, options }) => ({
            1: props,
            20: multi,
            21: decorator,
            22: options
          }),
          ({ props, multi, decorator, options }) => (props ? 2 : 0) | (multi ? 1048576 : 0) | (decorator ? 2097152 : 0) | (options ? 4194304 : 0)
        ]
      },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = dirty & 48 ? get_spread_update(switch_instance_spread_levels, [
        dirty & 32 && get_spread_object(ctx2[5]),
        dirty & 16 && { context: ctx2[4] }
      ]) : {};
      if (dirty & 15728707) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (switch_value !== (switch_value = ctx2[2])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: "(39:4) <svelte:component this={DecoratorWrapper} {context}>",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let div;
  let div_id_value;
  let setElem_action;
  let t;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[3] && ctx[2] && create_if_block2(ctx);
  const block = {
    c: function create() {
      div = element("div");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true });
      children(div).forEach(detach_dev);
      t = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "id", div_id_value = ctx[0].node.name);
      add_location(div, file, 34, 0, 1331);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(setElem_action = ctx[10].call(null, div));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & 1 && div_id_value !== (div_id_value = ctx2[0].node.name)) {
        attr_dev(div, "id", div_id_value);
      }
      if (ctx2[3] && ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 12) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (detaching)
        detach_dev(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  var _a;
  let isVisible;
  let params2;
  let load;
  let route;
  let compProps;
  let userContext;
  let $isActive;
  let $single;
  let $childFragments;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RenderFragment", slots, []);
  let { context: context2, props, activeContext } = $$props;
  const { isActive: isActive2, childFragments, single } = context2;
  validate_store(isActive2, "isActive");
  component_subscribe($$self, isActive2, (value) => $$invalidate(16, $isActive = value));
  validate_store(childFragments, "childFragments");
  component_subscribe($$self, childFragments, (value) => $$invalidate(6, $childFragments = value));
  validate_store(single, "single");
  component_subscribe($$self, single, (value) => $$invalidate(17, $single = value));
  let NodeComponent = ((_a = context2.node.module) == null ? void 0 : _a.default) || !context2.node.asyncModule && Noop_default;
  let elem;
  const setElem = (_elem) => $$invalidate(12, elem = _elem);
  setContext("routify-fragment-context", context2);
  const notExcludedCtx = (context3) => {
    var _a2;
    return !((_a2 = context3 == null ? void 0 : context3.node.meta.multi) == null ? void 0 : _a2.exclude);
  };
  const isPartOfPage = () => !$single && [context2, activeContext].every(notExcludedCtx);
  $$self.$$.on_mount.push(function() {
    if (context2 === void 0 && !("context" in $$props || $$self.$$.bound[$$self.$$.props["context"]])) {
      console.warn("<RenderFragment> was created without expected prop 'context'");
    }
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<RenderFragment> was created without expected prop 'props'");
    }
    if (activeContext === void 0 && !("activeContext" in $$props || $$self.$$.bound[$$self.$$.props["activeContext"]])) {
      console.warn("<RenderFragment> was created without expected prop 'activeContext'");
    }
  });
  const writable_props = ["context", "props", "activeContext"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<RenderFragment> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("props" in $$props2)
      $$invalidate(1, props = $$props2.props);
    if ("activeContext" in $$props2)
      $$invalidate(11, activeContext = $$props2.activeContext);
  };
  $$self.$capture_state = () => ({
    Component: ComposeFragments_default,
    setContext,
    DecoratorWrapper: DecoratorWrapper_default,
    Noop: Noop_default,
    context: context2,
    props,
    activeContext,
    isActive: isActive2,
    childFragments,
    single,
    NodeComponent,
    elem,
    setElem,
    notExcludedCtx,
    isPartOfPage,
    route,
    load,
    userContext,
    params: params2,
    compProps,
    isVisible,
    $isActive,
    $single,
    $childFragments
  });
  $$self.$inject_state = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("props" in $$props2)
      $$invalidate(1, props = $$props2.props);
    if ("activeContext" in $$props2)
      $$invalidate(11, activeContext = $$props2.activeContext);
    if ("NodeComponent" in $$props2)
      $$invalidate(2, NodeComponent = $$props2.NodeComponent);
    if ("elem" in $$props2)
      $$invalidate(12, elem = $$props2.elem);
    if ("route" in $$props2)
      $$invalidate(13, route = $$props2.route);
    if ("load" in $$props2)
      $$invalidate(14, load = $$props2.load);
    if ("userContext" in $$props2)
      $$invalidate(4, userContext = $$props2.userContext);
    if ("params" in $$props2)
      $$invalidate(15, params2 = $$props2.params);
    if ("compProps" in $$props2)
      $$invalidate(5, compProps = $$props2.compProps);
    if ("isVisible" in $$props2)
      $$invalidate(3, isVisible = $$props2.isVisible);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 6145) {
      $:
        if (elem && context2 === activeContext) {
          const _elem = elem;
          context2.fragment.setElem(_elem);
          _elem["__routify_meta"] = _elem["__routify_meta"] || {};
          _elem["__routify_meta"].renderContext = context2;
        }
    }
    if ($$self.$$.dirty & 65536) {
      $:
        $$invalidate(3, isVisible = $isActive || isPartOfPage());
    }
    if ($$self.$$.dirty & 13) {
      $:
        if (!NodeComponent && isVisible)
          context2.node.getRawComponent().then((r) => $$invalidate(2, NodeComponent = r));
    }
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(15, { params: params2, load, route } = context2.fragment, params2, ($$invalidate(14, load), $$invalidate(0, context2)), ($$invalidate(13, route), $$invalidate(0, context2)));
    }
    if ($$self.$$.dirty & 49154) {
      $:
        $$invalidate(5, compProps = { ...params2, ...load == null ? void 0 : load.props, ...props });
    }
    if ($$self.$$.dirty & 24577) {
      $:
        $$invalidate(4, userContext = { ...context2, load, route });
    }
  };
  return [
    context2,
    props,
    NodeComponent,
    isVisible,
    userContext,
    compProps,
    $childFragments,
    isActive2,
    childFragments,
    single,
    setElem,
    activeContext,
    elem,
    route,
    load,
    params2,
    $isActive
  ];
}
var RenderFragment = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { context: 0, props: 1, activeContext: 11 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RenderFragment",
      options,
      id: create_fragment4.name
    });
  }
  get context() {
    throw new Error("<RenderFragment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<RenderFragment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error("<RenderFragment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<RenderFragment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeContext() {
    throw new Error("<RenderFragment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeContext(value) {
    throw new Error("<RenderFragment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RenderFragment_default = RenderFragment;

// node_modules/@roxi/routify/lib/runtime/renderer/utils/normalizeMulti.js
var nodeIsPage = (node2) => {
  var _a;
  return !node2.meta.fallback && !node2.name.startsWith("_") && ((_a = node2.meta) == null ? void 0 : _a.order) !== false;
};
var getChildren = (refNode, parentContext) => {
  const parentNode = (parentContext == null ? void 0 : parentContext.node) || refNode.parent;
  const matches = parentNode ? parentNode.children.filter((node2) => node2 === refNode || nodeIsPage(node2)) : [refNode];
  return matches.length ? matches : [refNode];
};
var coerceStringToNode = (nodeOrString, refNode) => typeof nodeOrString === "string" ? refNode.traverse(nodeOrString) : nodeOrString;
var coercePagesToNodes = (pagesInput, refNode, parentContext) => {
  const pageInputs = Array.isArray(pagesInput) ? pagesInput : getChildren(refNode, parentContext);
  return pageInputs.map((page) => coerceStringToNode(page, refNode));
};
var convertToObj = (multiInput) => multiInput instanceof Object ? !Array.isArray(multiInput) ? multiInput : { pages: multiInput } : {};
var normalizeMulti = (multiInput, refNode, parentContext) => {
  const multi = convertToObj(multiInput);
  multi.single = multi.single || !multiInput;
  multi.pages = coercePagesToNodes(multi.pages, refNode, parentContext);
  return multi;
};

// node_modules/@roxi/routify/lib/runtime/renderer/ComposeFragments.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[0] = list[i];
  return child_ctx;
}
function create_each_block(key_1, ctx) {
  let first;
  let renderfragment;
  let current;
  renderfragment = new RenderFragment_default({
    props: {
      context: ctx[0],
      props: ctx[5],
      activeContext: ctx[2]
    },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(renderfragment.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(renderfragment.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(renderfragment, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const renderfragment_changes = {};
      if (dirty & 2)
        renderfragment_changes.context = ctx[0];
      if (dirty & 4)
        renderfragment_changes.activeContext = ctx[2];
      renderfragment.$set(renderfragment_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(renderfragment.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(renderfragment.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      destroy_component(renderfragment, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(69:0) {#each childContexts as context (context.node.id)}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ctx[1];
  validate_each_argument(each_value);
  const get_key = (ctx2) => ctx2[0].node.id;
  validate_each_keys(ctx, each_value, get_each_context, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 38) {
        each_value = ctx2[1];
        validate_each_argument(each_value);
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block, each_1_anchor, get_each_context);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let $childFragments;
  let $isActive;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ComposeFragments", slots, []);
  let { context: context2 = null } = $$props;
  let { options = {} } = $$props;
  const { childFragments, isActive: isActive2 } = context2;
  validate_store(childFragments, "childFragments");
  component_subscribe($$self, childFragments, (value) => $$invalidate(7, $childFragments = value));
  validate_store(isActive2, "isActive");
  component_subscribe($$self, isActive2, (value) => $$invalidate(8, $isActive = value));
  const { multi, decorator, props, options: _options } = options;
  let activeContext;
  const buildChildContexts = () => {
    var _a;
    const setup = normalizeMulti(multi, (_a = $childFragments[0]) == null ? void 0 : _a.node, context2);
    return setup.pages.map((node2) => {
      var _a2;
      return {
        childFragments: writable([]),
        node: node2,
        fragment: new RouteFragment(null, node2, null, {}),
        isActive: writable(false),
        router: ((_a2 = $childFragments[0]) == null ? void 0 : _a2.route.router) || context2.router,
        route: null,
        parentContext: context2,
        onDestroy: createSequenceHooksCollection(),
        decorators: [context2 == null ? void 0 : context2.decorators, decorator].flat().filter(Boolean),
        options: _options || {},
        single: writable(setup.single)
      };
    });
  };
  let childContexts = buildChildContexts();
  const handlePageChange = (fragments) => {
    const [fragment, ...childFragments2] = [...fragments];
    $$invalidate(2, activeContext = childContexts.find((s) => s.node.id === (fragment == null ? void 0 : fragment.node.id)));
    if (!activeContext) {
      $$invalidate(1, childContexts = buildChildContexts());
      return handlePageChange(fragments);
    }
    $$invalidate(2, activeContext.fragment = fragment, activeContext);
    activeContext.childFragments.set(childFragments2);
    $$invalidate(2, activeContext.route = fragments[0].route, activeContext);
    childContexts.forEach((s) => s.isActive.set(s === activeContext));
    $$invalidate(1, childContexts);
  };
  const writable_props = ["context", "options"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ComposeFragments> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("options" in $$props2)
      $$invalidate(6, options = $$props2.options);
  };
  $$self.$capture_state = () => ({
    createSequenceHooksCollection,
    writable,
    RouteFragment,
    RenderFragment: RenderFragment_default,
    normalizeMulti,
    context: context2,
    options,
    childFragments,
    isActive: isActive2,
    multi,
    decorator,
    props,
    _options,
    activeContext,
    buildChildContexts,
    childContexts,
    handlePageChange,
    $childFragments,
    $isActive
  });
  $$self.$inject_state = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("options" in $$props2)
      $$invalidate(6, options = $$props2.options);
    if ("activeContext" in $$props2)
      $$invalidate(2, activeContext = $$props2.activeContext);
    if ("childContexts" in $$props2)
      $$invalidate(1, childContexts = $$props2.childContexts);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 258) {
      $:
        if (isActive2 && !$isActive)
          childContexts.forEach((cc) => cc.isActive.set(false));
    }
    if ($$self.$$.dirty & 128) {
      $:
        $childFragments.length && handlePageChange($childFragments);
    }
  };
  return [
    context2,
    childContexts,
    activeContext,
    childFragments,
    isActive2,
    props,
    options,
    $childFragments,
    $isActive
  ];
}
var ComposeFragments = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { context: 0, options: 6 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ComposeFragments",
      options,
      id: create_fragment5.name
    });
  }
  get context() {
    throw new Error("<ComposeFragments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<ComposeFragments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<ComposeFragments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<ComposeFragments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ComposeFragments_default = ComposeFragments;

// node_modules/@roxi/routify/lib/runtime/helpers/scroll.js
var persistentScrollTo = (el, anchor, options, timeout) => {
  options = options || {};
  options.behavior = "auto";
  const limits = getScrollBoundaries();
  const observer = new MutationObserver((mo) => {
    if (mo.length > 1 || mo[0].addedNodes.length || mo[0].removedNodes.length)
      scopedScrollIntoView(el, anchor, limits);
  });
  observer.observe(document.body, {
    childList: true,
    subtree: true,
    attributes: true,
    characterData: true
  });
  const stopScroll = () => observer.disconnect();
  if (timeout) {
    return new Promise(
      (resolve) => setTimeout(() => {
        stopScroll();
        resolve();
      }, timeout)
    );
  } else {
    timeout;
    return stopScroll;
  }
};
var getScrollBoundaries = () => [
  ...document.querySelectorAll('[data-routify-scroll="lock"]'),
  ...appInstance.routers.filter((router) => router.parentCmpCtx).map((router) => router.parentElem)
];
var getMulti = (elem) => {
  var _a, _b, _c, _d, _e;
  if (!elem)
    return false;
  if ((_a = elem["__routify_meta"]) == null ? void 0 : _a.router)
    return false;
  if ((_c = (_b = elem["__routify_meta"]) == null ? void 0 : _b.renderContext) == null ? void 0 : _c.single)
    return !get_store_value((_e = (_d = elem["__routify_meta"]) == null ? void 0 : _d.renderContext) == null ? void 0 : _e.single);
  else
    return getMulti(elem.parentElement);
};
var scopedScrollIntoView = (elem, anchor, limits) => {
  limits = limits || getScrollBoundaries();
  let parent = elem.parentElement;
  const isAnchor = elem === anchor;
  while ((parent == null ? void 0 : parent.scrollTo) && !limits.includes(parent)) {
    if (!getMulti(elem) && !isAnchor) {
      parent.scrollTo(0, 0);
    } else {
      const targetRect = elem.getBoundingClientRect();
      const parentRect = parent.getBoundingClientRect();
      const top = targetRect.top - parentRect.top;
      const left = targetRect.left - parentRect.left;
      parent.scrollTo({ top, left });
    }
    if (!getMulti(elem) && !isAnchor)
      elem = parent;
    parent = parent.parentElement;
  }
};

// node_modules/@roxi/routify/lib/runtime/decorators/ScrollDecorator.svelte
function create_fragment6(ctx) {
  let current;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var scrollHandlers = /* @__PURE__ */ new Map();
var fetchScrollHandler = (router) => {
  if (!scrollHandlers.has(router))
    scrollHandlers.set(router, new ScrollHandler(router));
  return scrollHandlers.get(router);
};
var ScrollHandler = class {
  constructor(router) {
    this.router = router;
    this.stopPersistent = () => null;
    this.listenForScroll = true;
    if (typeof document !== "undefined") {
      addEventListener("scroll", () => this.onScroll(), { capture: true });
    }
    router.activeRoute.subscribe(async (route) => {
      if (route.state.dontScroll)
        return;
      const parentElem = await route.leaf.parentElem;
      const anchor = route.anchor && document.getElementById(route.anchor);
      const elem = anchor || parentElem;
      this.scrollTo(elem, anchor, true);
    });
  }
  scrollTo(elem, anchor, shouldPersist) {
    this.listenForScroll = false;
    setTimeout(() => this.listenForScroll = true, 500);
    setTimeout(async () => {
      scopedScrollIntoView(elem, anchor);
      if (shouldPersist) {
        this.stopPersistent();
        this.stopPersistent = persistentScrollTo(elem, anchor, {});
        setTimeout(this.stopPersistent, 500);
      }
    });
  }
  onScroll() {
    throttle(async () => {
      this._onScrollThrottled();
      await new Promise((resolve) => setTimeout(resolve, 100));
    });
  }
  _onScrollThrottled() {
    if (!this.listenForScroll)
      return;
    let candidateElement;
    let candidateTop = -Infinity;
    const renderElements = [...document.querySelectorAll("*")].filter((x) => {
      var _a;
      const ctx = (_a = x["__routify_meta"]) == null ? void 0 : _a.renderContext;
      return ctx && get_store_value(ctx.single) === false;
    });
    const cutoff = window.innerHeight / 3;
    for (const element2 of renderElements) {
      const { top } = element2.getBoundingClientRect();
      if (cutoff > top && (top > candidateTop || element2["__routify_meta"].renderContext.node.ancestors.includes(candidateElement["__routify_meta"].renderContext.node))) {
        candidateElement = element2;
        candidateTop = top;
      }
    }
    if (candidateElement) {
      const context2 = candidateElement["__routify_meta"].renderContext;
      if (context2.router.activeRoute.get() != context2.route)
        context2.router.url.set(context2.node.path, "replaceState", true, {
          dontScroll: true
        });
    }
  }
};
function instance6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ScrollDecorator", slots, ["default"]);
  let { context: context2 } = $$props;
  let { Parent } = $$props;
  Parent;
  const { router } = context2;
  fetchScrollHandler(router);
  $$self.$$.on_mount.push(function() {
    if (context2 === void 0 && !("context" in $$props || $$self.$$.bound[$$self.$$.props["context"]])) {
      console.warn("<ScrollDecorator> was created without expected prop 'context'");
    }
    if (Parent === void 0 && !("Parent" in $$props || $$self.$$.bound[$$self.$$.props["Parent"]])) {
      console.warn("<ScrollDecorator> was created without expected prop 'Parent'");
    }
  });
  const writable_props = ["context", "Parent"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ScrollDecorator> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("Parent" in $$props2)
      $$invalidate(1, Parent = $$props2.Parent);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    get: get_store_value,
    throttle,
    scopedScrollIntoView,
    persistentScrollTo,
    scrollHandlers,
    fetchScrollHandler,
    ScrollHandler,
    context: context2,
    Parent,
    router
  });
  $$self.$inject_state = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("Parent" in $$props2)
      $$invalidate(1, Parent = $$props2.Parent);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [context2, Parent, $$scope, slots];
}
var ScrollDecorator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { context: 0, Parent: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ScrollDecorator",
      options,
      id: create_fragment6.name
    });
  }
  get context() {
    throw new Error("<ScrollDecorator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<ScrollDecorator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get Parent() {
    throw new Error("<ScrollDecorator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Parent(value) {
    throw new Error("<ScrollDecorator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ScrollDecorator_default = ScrollDecorator;

// node_modules/@roxi/routify/lib/runtime/Router/Router.svelte
var file2 = "node_modules\\@roxi\\routify\\lib\\runtime\\Router\\Router.svelte";
function create_if_block_13(ctx) {
  let div;
  let component;
  let initialize_action;
  let current;
  let mounted;
  let dispose;
  component = new ComposeFragments_default({
    props: {
      context: ctx[5],
      options: { decorator: ctx[1] }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(component.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { "data-routify": true, style: true });
      var div_nodes = children(div);
      claim_component(component.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "data-routify", ctx[3]);
      set_style(div, "display", "contents");
      add_location(div, file2, 92, 4, 3145);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(component, div, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(initialize_action = ctx[6].call(null, div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      const component_changes = {};
      if (dirty & 2)
        component_changes.options = { decorator: ctx2[1] };
      component.$set(component_changes);
      if (!current || dirty & 8) {
        attr_dev(div, "data-routify", ctx2[3]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(component.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(component.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(component);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(92:0) {#if $activeRoute}",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let div;
  let router_setParentElem_action;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div, file2, 98, 4, 3317);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(router_setParentElem_action = ctx[0].setParentElem(div));
        mounted = true;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(98:0) {#if !router.parentElem}",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let t;
  let if_block1_anchor;
  let current;
  let if_block0 = ctx[2] && create_if_block_13(ctx);
  let if_block1 = !ctx[0].parentElem && create_if_block3(ctx);
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[2]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_13(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!ctx2[0].parentElem) {
        if (if_block1) {
        } else {
          if_block1 = create_if_block3(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(if_block1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_1($$self, $$props, $$invalidate) {
  let activeRoute2;
  let nodeId;
  let $activeRoute, $$unsubscribe_activeRoute = noop, $$subscribe_activeRoute = () => ($$unsubscribe_activeRoute(), $$unsubscribe_activeRoute = subscribe(activeRoute2, ($$value) => $$invalidate(2, $activeRoute = $$value)), activeRoute2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_activeRoute());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Router", slots, []);
  let { router = null } = $$props;
  let { routes = null } = $$props;
  let { decorator = ScrollDecorator_default } = $$props;
  let { urlReflector = null } = $$props;
  let { instance: instance7 = null } = $$props;
  let { urlRewrite = null } = $$props;
  let { url: url2 = null } = $$props;
  let { name = null } = $$props;
  let { rootNode = null } = $$props;
  let { passthrough = null } = $$props;
  let { beforeRouterInit = null } = $$props;
  let { afterRouterInit = null } = $$props;
  let { beforeUrlChange: beforeUrlChange2 = null } = $$props;
  let { afterUrlChange: afterUrlChange2 = null } = $$props;
  let { transformFragments = null } = $$props;
  let { onDestroy: onDestroy2 = null } = $$props;
  let { plugins = null } = $$props;
  let { queryHandler = null } = $$props;
  const context2 = { childFragments: writable([]) };
  const options = {
    instance: instance7,
    rootNode,
    name,
    routes,
    urlRewrite,
    urlReflector,
    passthrough,
    beforeRouterInit,
    afterRouterInit,
    beforeUrlChange: beforeUrlChange2,
    afterUrlChange: afterUrlChange2,
    transformFragments,
    onDestroy: onDestroy2,
    plugins,
    queryHandler
  };
  if (!router)
    router = new Router(options);
  const initialize = (elem) => {
    if (!router.passthrough) {
      elem.addEventListener("click", handleClick);
      elem.addEventListener("keydown", handleClick);
    }
  };
  const handleClick = (event) => {
    const url3 = getUrlFromClick(event);
    if (url3)
      router.url.push(url3);
  };
  if (typeof window !== "undefined")
    onDestroy(() => router.destroy());
  const writable_props = [
    "router",
    "routes",
    "decorator",
    "urlReflector",
    "instance",
    "urlRewrite",
    "url",
    "name",
    "rootNode",
    "passthrough",
    "beforeRouterInit",
    "afterRouterInit",
    "beforeUrlChange",
    "afterUrlChange",
    "transformFragments",
    "onDestroy",
    "plugins",
    "queryHandler"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Router> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("router" in $$props2)
      $$invalidate(0, router = $$props2.router);
    if ("routes" in $$props2)
      $$invalidate(7, routes = $$props2.routes);
    if ("decorator" in $$props2)
      $$invalidate(1, decorator = $$props2.decorator);
    if ("urlReflector" in $$props2)
      $$invalidate(8, urlReflector = $$props2.urlReflector);
    if ("instance" in $$props2)
      $$invalidate(9, instance7 = $$props2.instance);
    if ("urlRewrite" in $$props2)
      $$invalidate(10, urlRewrite = $$props2.urlRewrite);
    if ("url" in $$props2)
      $$invalidate(11, url2 = $$props2.url);
    if ("name" in $$props2)
      $$invalidate(12, name = $$props2.name);
    if ("rootNode" in $$props2)
      $$invalidate(13, rootNode = $$props2.rootNode);
    if ("passthrough" in $$props2)
      $$invalidate(14, passthrough = $$props2.passthrough);
    if ("beforeRouterInit" in $$props2)
      $$invalidate(15, beforeRouterInit = $$props2.beforeRouterInit);
    if ("afterRouterInit" in $$props2)
      $$invalidate(16, afterRouterInit = $$props2.afterRouterInit);
    if ("beforeUrlChange" in $$props2)
      $$invalidate(17, beforeUrlChange2 = $$props2.beforeUrlChange);
    if ("afterUrlChange" in $$props2)
      $$invalidate(18, afterUrlChange2 = $$props2.afterUrlChange);
    if ("transformFragments" in $$props2)
      $$invalidate(19, transformFragments = $$props2.transformFragments);
    if ("onDestroy" in $$props2)
      $$invalidate(20, onDestroy2 = $$props2.onDestroy);
    if ("plugins" in $$props2)
      $$invalidate(21, plugins = $$props2.plugins);
    if ("queryHandler" in $$props2)
      $$invalidate(22, queryHandler = $$props2.queryHandler);
  };
  $$self.$capture_state = () => ({
    Router,
    _onDestroy: onDestroy,
    getUrlFromClick,
    Component: ComposeFragments_default,
    ScrollDecorator: ScrollDecorator_default,
    get: get_store_value,
    writable,
    appInstance,
    router,
    routes,
    decorator,
    urlReflector,
    instance: instance7,
    urlRewrite,
    url: url2,
    name,
    rootNode,
    passthrough,
    beforeRouterInit,
    afterRouterInit,
    beforeUrlChange: beforeUrlChange2,
    afterUrlChange: afterUrlChange2,
    transformFragments,
    onDestroy: onDestroy2,
    plugins,
    queryHandler,
    context: context2,
    options,
    initialize,
    handleClick,
    nodeId,
    activeRoute: activeRoute2,
    $activeRoute
  });
  $$self.$inject_state = ($$props2) => {
    if ("router" in $$props2)
      $$invalidate(0, router = $$props2.router);
    if ("routes" in $$props2)
      $$invalidate(7, routes = $$props2.routes);
    if ("decorator" in $$props2)
      $$invalidate(1, decorator = $$props2.decorator);
    if ("urlReflector" in $$props2)
      $$invalidate(8, urlReflector = $$props2.urlReflector);
    if ("instance" in $$props2)
      $$invalidate(9, instance7 = $$props2.instance);
    if ("urlRewrite" in $$props2)
      $$invalidate(10, urlRewrite = $$props2.urlRewrite);
    if ("url" in $$props2)
      $$invalidate(11, url2 = $$props2.url);
    if ("name" in $$props2)
      $$invalidate(12, name = $$props2.name);
    if ("rootNode" in $$props2)
      $$invalidate(13, rootNode = $$props2.rootNode);
    if ("passthrough" in $$props2)
      $$invalidate(14, passthrough = $$props2.passthrough);
    if ("beforeRouterInit" in $$props2)
      $$invalidate(15, beforeRouterInit = $$props2.beforeRouterInit);
    if ("afterRouterInit" in $$props2)
      $$invalidate(16, afterRouterInit = $$props2.afterRouterInit);
    if ("beforeUrlChange" in $$props2)
      $$invalidate(17, beforeUrlChange2 = $$props2.beforeUrlChange);
    if ("afterUrlChange" in $$props2)
      $$invalidate(18, afterUrlChange2 = $$props2.afterUrlChange);
    if ("transformFragments" in $$props2)
      $$invalidate(19, transformFragments = $$props2.transformFragments);
    if ("onDestroy" in $$props2)
      $$invalidate(20, onDestroy2 = $$props2.onDestroy);
    if ("plugins" in $$props2)
      $$invalidate(21, plugins = $$props2.plugins);
    if ("queryHandler" in $$props2)
      $$invalidate(22, queryHandler = $$props2.queryHandler);
    if ("nodeId" in $$props2)
      $$invalidate(3, nodeId = $$props2.nodeId);
    if ("activeRoute" in $$props2)
      $$subscribe_activeRoute($$invalidate(4, activeRoute2 = $$props2.activeRoute));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2049) {
      $:
        if (url2 && url2 !== router.url.internal())
          router.url.replace(url2);
    }
    if ($$self.$$.dirty & 1) {
      $:
        $$subscribe_activeRoute($$invalidate(4, activeRoute2 = router.activeRoute));
    }
    if ($$self.$$.dirty & 4) {
      $:
        context2.childFragments.set(($activeRoute == null ? void 0 : $activeRoute.fragments) || []);
    }
    if ($$self.$$.dirty & 4) {
      $:
        $$invalidate(3, nodeId = $activeRoute == null ? void 0 : $activeRoute.fragments[0].node.name);
    }
    if ($$self.$$.dirty & 1) {
      $:
        router.log.debug("before render", get_store_value(context2.childFragments));
    }
  };
  return [
    router,
    decorator,
    $activeRoute,
    nodeId,
    activeRoute2,
    context2,
    initialize,
    routes,
    urlReflector,
    instance7,
    urlRewrite,
    url2,
    name,
    rootNode,
    passthrough,
    beforeRouterInit,
    afterRouterInit,
    beforeUrlChange2,
    afterUrlChange2,
    transformFragments,
    onDestroy2,
    plugins,
    queryHandler
  ];
}
var Router_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_1, create_fragment7, safe_not_equal, {
      router: 0,
      routes: 7,
      decorator: 1,
      urlReflector: 8,
      instance: 9,
      urlRewrite: 10,
      url: 11,
      name: 12,
      rootNode: 13,
      passthrough: 14,
      beforeRouterInit: 15,
      afterRouterInit: 16,
      beforeUrlChange: 17,
      afterUrlChange: 18,
      transformFragments: 19,
      onDestroy: 20,
      plugins: 21,
      queryHandler: 22
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Router_1",
      options,
      id: create_fragment7.name
    });
  }
  get router() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set router(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get routes() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set routes(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get decorator() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set decorator(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get urlReflector() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set urlReflector(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set instance(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get urlRewrite() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set urlRewrite(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get url() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set url(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rootNode() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rootNode(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get passthrough() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set passthrough(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get beforeRouterInit() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set beforeRouterInit(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get afterRouterInit() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set afterRouterInit(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get beforeUrlChange() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set beforeUrlChange(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get afterUrlChange() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set afterUrlChange(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transformFragments() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transformFragments(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onDestroy() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onDestroy(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get plugins() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set plugins(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get queryHandler() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set queryHandler(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Router_default = Router_1;

// node_modules/@roxi/routify/lib/runtime/Router/urlReflectors/LocalStorage.js
var LocalStorageReflector = class extends BaseReflector {
  constructor(router) {
    super(router);
    this.storageName = `__routify-router-${this.router.name}`;
  }
  reflect() {
    window.localStorage.setItem(this.storageName, this.router.url.internal());
  }
};

// node_modules/@roxi/routify/lib/runtime/helpers/index.js
var getMRCA = (node1, node2) => {
  const lineage1 = [node1, ...node1.ancestors];
  const lineage2 = [node2, ...node2.ancestors];
  return lineage1.find((node3) => lineage2.includes(node3));
};
var getPath = (node1, node2) => {
  const lineage1 = [node1, ...node1.ancestors];
  const lineage2 = [node2, ...node2.ancestors];
  const mrca = getMRCA(node1, node2);
  const backtrackSteps = lineage1.indexOf(mrca);
  const backtrackStr = backtrackSteps ? "../".repeat(backtrackSteps) : "";
  const forwardSteps = lineage2.indexOf(mrca);
  const forwardStepsStr = lineage2.slice(0, forwardSteps).reverse().map((n) => n.name).join("/");
  return backtrackStr + forwardStepsStr;
};
var goto = {
  subscribe: (run, invalidate) => {
    const { router } = contexts;
    return derived(url, ($url) => (path, userParams, options) => {
      const defaults2 = { mode: "push" };
      options = { ...defaults2, ...options };
      const newUrl = $url(path, userParams);
      router.url[options.mode](newUrl);
    }).subscribe(run, invalidate);
  }
};
var url = {
  subscribe: (run, invalidate) => {
    const { router } = contexts;
    const originalOriginNode = contexts.fragment.node;
    return derived(router.activeRoute, (activeRoute2) => {
      const originNode = router.rootNode.traverse(originalOriginNode.path);
      return (inputPath, userParams = {}) => {
        const offset = inputPath.startsWith("/") ? router.rootNode.path : "";
        const targetNode = originNode.traverse(offset + inputPath);
        if (!targetNode) {
          console.error("could not find destination node", inputPath);
          return;
        }
        const mrca = getMRCA(targetNode, router.rootNode);
        const path = ("/" + getPath(mrca, targetNode)).replace(/\/index$/, "/");
        const params2 = {
          ...inheritedParams(targetNode, activeRoute2),
          ...userParams
        };
        const internalUrl = populateUrl(path, params2, activeRoute2);
        return router.getExternalUrl(internalUrl);
      };
    }).subscribe(run, invalidate);
  }
};
var inheritedParams = (node2, route) => {
  const lineage = [node2, ...node2.ancestors].reverse();
  const params2 = lineage.map(
    (_node) => {
      var _a;
      return (_a = route.allFragments.find(
        (fragment) => fragment.node === _node || fragment.node.path === _node.path
      )) == null ? void 0 : _a.params;
    }
  );
  return Object.assign({}, ...params2);
};
var params = {
  subscribe: (run, invalidate) => derived(contexts.router.params, (params2) => params2).subscribe(run, invalidate)
};
var isActive = {
  subscribe: (run, invalidate) => derived(contexts.router.activeRoute, isActiveRoute).subscribe(run, invalidate)
};
var isActiveRoute = ($route) => isActiveUrl($route.url, $route.params);
var isActiveUrl = (url2, actualParams = {}) => {
  const stripLastIndexAndSlash = (str) => str.replace(/(\/index)?\/*$/, "");
  url2 = url2.replace(/[?#].+/, "");
  url2 = stripLastIndexAndSlash(url2);
  return (path, params2 = {}, options = {}) => {
    const { recursive } = { recursive: true, ...options };
    for (const wantedParam of Object.keys(params2))
      if (actualParams[wantedParam] !== params2[wantedParam])
        return false;
    path = pathAndParamsToUrl(path, { ...actualParams, ...params2 }, (x) => "", true);
    path = stripLastIndexAndSlash(path);
    const suffix = recursive ? "(/|$)" : "/?$";
    const regexPath = new RegExp(`^${path}${suffix}`);
    return regexPath.test(url2);
  };
};
var resolveNode = (path) => {
  const { node: node2 } = contexts.fragment;
  const { router } = contexts;
  return traverseNode(node2, path, router);
};
var traverseNode = (node2, path, router) => path.startsWith("/") ? router.rootNode.traverse(`.${path}`) : node2.traverse(path);
var pseudoStore = (callback) => ({
  subscribe: (run) => {
    run(callback());
    return () => {
    };
  }
});
var context = pseudoStore(() => contexts.fragment);
var node = pseudoStore(() => get_store_value(context).node);
var meta = pseudoStore(() => get_store_value(node).meta);
var activeRoute = {
  subscribe: (run) => contexts.router.activeRoute.subscribe(run)
};
var pendingRoute = {
  subscribe: (run) => contexts.router.pendingRoute.subscribe(run)
};
var afterUrlChange = {
  subscribe: (run) => {
    const hookHandles = [];
    const register = (callback) => {
      const unhook = contexts.router.afterUrlChange(callback);
      hookHandles.push(unhook);
      return unhook;
    };
    run(register);
    return () => hookHandles.map((unhook) => unhook());
  }
};
var beforeUrlChange = {
  subscribe: (run) => {
    const hookHandles = [];
    const register = (callback) => {
      const unhook = contexts.router.beforeUrlChange(callback);
      hookHandles.push(unhook);
      return unhook;
    };
    run(register);
    return () => hookHandles.map((unhook) => unhook());
  }
};

// node_modules/@roxi/routify/lib/common/helpers.js
var gentleAssign = (target, ...sources) => {
  sources.forEach(
    (source) => Object.keys(source).forEach((key) => {
      var _a;
      return target[key] = (_a = target[key]) != null ? _a : source[key];
    })
  );
  return target;
};
var assignNode = (target, ...sources) => {
  gentleAssign(target, ...sources);
  gentleAssign(target.meta, ...sources.map((s) => s.meta));
  sources.forEach((source) => {
    source.children.forEach((sNode) => {
      let tNode = target.children.find((tNode2) => tNode2.name === sNode.name);
      if (!tNode)
        tNode = target.createChild(null, null);
      assignNode(tNode, sNode);
    });
  });
  return target;
};
var findNearestParent = (node2, callback) => {
  let parent = node2.parent;
  while (parent) {
    if (callback(parent))
      return parent;
    parent = parent.parent;
  }
};
var getDistance = (parentNode, childNode) => {
  let child = null;
  let distance = 0;
  while (child = childNode.parent) {
    distance++;
    if (parentNode === childNode)
      return distance;
  }
};

// node_modules/@roxi/routify/lib/runtime/index.js
var Routify2 = RoutifyRuntime;
export {
  AddressReflector,
  ComposeFragments_default as Component,
  InternalReflector,
  LocalStorageReflector,
  Router_default as Router,
  Router as RouterClass,
  Routify2 as Routify,
  activeRoute,
  afterUrlChange,
  appInstance,
  assignNode,
  beforeUrlChange,
  context,
  createRouter,
  findNearestParent,
  getDistance,
  getMRCA,
  getPath,
  getScrollBoundaries,
  goto,
  isActive,
  isActiveRoute,
  isActiveUrl,
  meta,
  node,
  params,
  pendingRoute,
  persistentScrollTo,
  resolveNode,
  scopedScrollIntoView,
  traverseNode,
  url
};
//# sourceMappingURL=@roxi_routify.js.map
